#include <Precomp.h>

#include <Core/System/Debug.h>
#include <Core/System/File.h>

#include <Core/Graphics/Texture.h>
#include <Core/Graphics/Vulkan.h>
#include <Core/Graphics/Vulkan/Device.h>
#include <Core/Graphics/Vulkan/TextureManager.h>

namespace AV {

using namespace std;

// =====================================================================================================================
// Utility functions and constants.

static const int NumChannels[(int)TextureFormat::Count] =
{
	4,
	2,
	1,
	1,
};

static const PixelFormat PixelFormats[(int)TextureFormat::Count] =
{
	PixelFormat::RGBA,
	PixelFormat::LumA,
	PixelFormat::Lum,
	PixelFormat::Alpha,
};

static const TextureFormat TextureFormats[(int)PixelFormat::Count] =
{
	TextureFormat::RGBA,
	TextureFormat::RGBA, // Texture format RGB is not supported, use RGBA instead.
	TextureFormat::LumA,
	TextureFormat::Lum,
	TextureFormat::Alpha,
};

static bool IsPowerOfTwo(int width, int height)
{
	return (width & (width - 1)) == 0 && (height & (height - 1)) == 0;
}

static int NextPowerOfTwo(int value)
{
	--value;
	value |= value >> 1;
	value |= value >> 2;
	value |= value >> 4;
	value |= value >> 8;
	value |= value >> 16;
	++value;
	return value;
}

static void Downscale(const uchar* in, uchar* out, int width, int height, int stride, TextureFormat format)
{
	int numChannels = NumChannels[(int)format];
	int bytesPerLine = stride * numChannels;
	if (numChannels == 4)
	{
		auto line = in;
		for (int y = 0; y < height; y += 2, line += bytesPerLine)
		{
			auto pixel = line;
			for (int x = 0; x < width; x += 2, out += numChannels, pixel += numChannels)
			{
				auto a = pixel, b = a + numChannels, c = a + bytesPerLine, d = c + numChannels;
				int alphaSum = a[3] + b[3] + c[3] + d[3];
				if (alphaSum > 0)
				{
					for (int i = 0; i < 3; ++i)
					{
						out[i] = (a[i] * a[3] + b[i] * b[3] + c[i] * c[3] + d[i] * d[3]) / alphaSum;
					}
					out[3] = alphaSum / 4;
				}
				else
				{
					out[0] = out[1] = out[2] = out[3] = 0;
				}
			}
		}
	}
	else if (numChannels == 2)
	{
		auto line = in;
		for (int y = 0; y < height; y += 2, line += bytesPerLine)
		{
			auto pixel = line;
			for (int x = 0; x < width; x += 2, out += numChannels, pixel += numChannels)
			{
				auto a = pixel, b = a + numChannels, c = a + bytesPerLine, d = c + numChannels;
				int alphaSum = a[1] + b[1] + c[1] + d[1];
				if (alphaSum > 0)
				{
					out[0] = (a[0] * a[1] + b[0] * b[1] + c[0] * c[1] + d[0] * d[1]) / alphaSum;
					out[1] = alphaSum / 4;
				}
				else
				{
					out[0] = out[1] = 0;
				}
			}
		}
	}
	else if (numChannels == 1)
	{
		auto line = in;
		for (int y = 0; y < height; y += 2, line += bytesPerLine)
		{
			auto pixel = line;
			for (int x = 0; x < width; x += 2, out += numChannels, pixel += numChannels)
			{
				auto a = pixel, b = a + numChannels, c = a + bytesPerLine, d = c + numChannels;
				out[0] = (a[0] + b[0] + c[0] + d[0]) / 4;
			}
		}
	}
}

static void GenerateMipmapLevels(const uchar* in, int width, int height, int stride, TextureFormat format)
{
	int numChannels = NumChannels[(int)format];

	uchar* bufferA = (uchar*)malloc((width / 2) * (height / 2) * numChannels);
	uchar* bufferB = (uchar*)malloc((width / 4) * (height / 4) * numChannels);

	// The first mipmap level is generated from the source buffer.
	Downscale(in, bufferA, width, height, stride, format);
	width /= 2, height /= 2;
	// glTexImage2D(GL_TEXTURE_2D, 1, InternalFormatsGL[(int)format], width, height, 0, FormatsGL[(int)format], GL_UNSIGNED_BYTE, bufferA);

	// Subsequent mipmap levels are generated by swapping temporary buffers.
	for (int n = 2; width >= 2 && height >= 2; ++n)
	{
		Downscale(bufferA, bufferB, width, height, width, format);
		width /= 2, height /= 2;
		// glTexImage2D(GL_TEXTURE_2D, n, InternalFormatsGL[(int)format], width, height, 0, FormatsGL[(int)format], GL_UNSIGNED_BYTE, bufferB);
		swap(bufferA, bufferB);
	}

	free(bufferA);
	free(bufferB);
}

static void ApplyFiltersAndMipmap(const uchar* in, int width, int height, int stride, TextureFormat format)
{
	if (false)
	{
		if (/*Glx::supportsMipmapGeneration*/ true)
		{
			// Glx::glGenerateMipmap(GL_TEXTURE_2D);
		}
		else if (IsPowerOfTwo(width, height) && width == height)
		{
			GenerateMipmapLevels(in, width, height, stride, format);
		}
		else
		{
			// filter = TextureFilter::Linear;
		}
	}

	// int minFilter = FiltersGL[(int)filter];
	// int maxFilter = (filter == TextureFilter::Nearest) ? GL_NEAREST : GL_LINEAR;

	// glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);
	// glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, maxFilter);
	// glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	// glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
}

static unique_ptr<Vk::Image> ApplyTextureImage(const uchar* pixels, int width, int height, int stride,
	PixelFormat pixelFormat, TextureFormat format)
{
	// Convert from the input pixel format to the target pixel format.
	uchar* convertedPixels = nullptr;
	auto targetPixelFormat = PixelFormats[(int)format];
	if (pixelFormat != targetPixelFormat)
	{
		pixels = convertedPixels = Image::convert(pixels, width, height, stride, pixelFormat,
			targetPixelFormat).pixels;
		pixelFormat = targetPixelFormat;
		stride = width;
	}

	auto numChannels = NumChannels[(int)format];
	VkDeviceSize imageSize = width * height * numChannels;

	auto stagingBuffer = Vk::Buffer::create(
		imageSize,
		VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

	if (!stagingBuffer)
		return nullptr;

	void* mappedData;
	if (VkGuard(vkMapMemory(Vk::device, stagingBuffer->memory, 0, imageSize, 0, &mappedData)))
	{
		Image::release(convertedPixels);
		return nullptr;
	}
	for (int y = 0; y < height; ++y)
		memcpy((uchar*)mappedData + y * width * numChannels, pixels + y * stride * numChannels, width * numChannels);
	vkUnmapMemory(Vk::device, stagingBuffer->memory);

	auto image = Vk::TextureManager::create(width, height, pixelFormat);

	if (!image)
		return nullptr;

	if (!image->transitionLayout(VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL))
		return nullptr;

	image->copyFromBuffer(stagingBuffer->buffer, width, height);

	if (!image->transitionLayout(VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL))
		return nullptr;

	return image;
}

// =====================================================================================================================
// Texture.

Texture::~Texture()
{
}

Texture::Texture()
	: myWidth(0)
	, myHeight(0)
	, myFormat(TextureFormat::RGBA)
{
}

Texture::Texture(Texture&& texture) noexcept
	: myWidth(texture.myWidth)
	, myHeight(texture.myHeight)
	, myFormat(texture.myFormat)
{
	myImage.swap(texture.myImage);
}

Texture::Texture(const FilePath& path, TextureFormat format, Color transparentFill)
{
	myFormat = format;
	auto pixelFormat = Texture::getPixelFormat(format);
	Image::Data image = Image::load(path, pixelFormat);
	if (image.pixels)
	{
		myWidth = image.width;
		myHeight = image.height;
		myImage = ApplyTextureImage(image.pixels, image.width, image.height, image.width, pixelFormat, format);
	}
	else
	{
		myWidth = 0;
		myHeight = 0;
	}
}

Texture::Texture(int width, int height, TextureFormat format)
	: Texture(nullptr, width, height, width, PixelFormat::RGBA, format)
{
}

Texture::Texture(const uchar* pixels, int width, int height, PixelFormat pixelFormat, TextureFormat format)
	: Texture(pixels, width, height, width, pixelFormat, format)
{
}

Texture::Texture(const uchar* pixels, int width, int height, int stride, PixelFormat pixelFormat, TextureFormat format)
{
	VortexAssert(width >= 1);
	VortexAssert(height >= 1);
	VortexAssert(stride >= 1);

	myWidth = width;
	myHeight = height;
	myFormat = format;
	if (pixels)
		myImage = ApplyTextureImage(pixels, width, height, stride, pixelFormat, format);
}
void Texture::operator = (Texture&& texture) noexcept
{
	myWidth = texture.myWidth;
	myHeight = texture.myHeight;
	myFormat = texture.myFormat;
	myImage.swap(texture.myImage);
}

int Texture::createTiles(const FilePath& path, int tileWidth, int tileHeight, int numTiles, Texture* outTiles, TextureFormat format)
{
	auto pixelFormat = Texture::getPixelFormat(format);
	int numChannels = Image::numChannels(pixelFormat);
	int tileIndex = 0;

	// Image::Data image = Image::load(path, pixelFormat);
	// for (int y = 0; y + tileHeight <= image.height; y += tileHeight)
	// {
	// 	for (int x = 0; x + tileWidth <= image.width; x += tileWidth)
	// 	{
	// 		if (tileIndex < numTiles)
	// 		{
	// 			uchar* pixels = image.pixels + ((y * image.width) + x) * numChannels;
	// 			outTiles[tileIndex++] = Texture(pixels, tileWidth, tileHeight, image.width, pixelFormat, format, filter);
	// 		}
	// 	}
	// }
	// Image::release(image.pixels);

	return tileIndex;
}

PixelFormat Texture::getPixelFormat(TextureFormat format)
{
	return PixelFormats[(int)format];
}

void Texture::modify(const uchar* pixels, int x, int y, int width, int height, int stride,
	PixelFormat pixelFormat)
{
	VortexAssert(x >= 0 && x + width <= myWidth);
	VortexAssert(y >= 0 && y + height <= myHeight);

	// glBindTexture(GL_TEXTURE_2D, myHandle);

	// Convert from the input pixel format to the target pixel format.
	uchar* convertedPixels = nullptr;
	auto targetPixelFormat = PixelFormats[(int)myFormat];
	if (pixelFormat != targetPixelFormat)
	{
		pixels = convertedPixels = Image::convert(pixels, width, height, width, pixelFormat,
			targetPixelFormat).pixels;
		pixelFormat = targetPixelFormat;
		stride = width;
	}

	// Change the unpack row length if the image has a stride larger than the line width.
	bool hasStride = (stride > width);
	// if (hasStride) glPixelStorei(GL_UNPACK_ROW_LENGTH, stride);

	// Change the unpack alignment for pixel rows that are not aligned to 4-byte boundaries.
	auto numChannels = NumChannels[(int)myFormat];
	bool isUnaligned = (((width * numChannels) & 3) != 0);
	// if (isUnaligned) glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	// Modify the image.
	// glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, FormatsGL[(int)myFormat], GL_UNSIGNED_BYTE, pixels);

	// Restore the unpack alignment.
	// if (isUnaligned) glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

	// Restore the unpack row length.
	// if (hasStride) glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

	// Free temporary buffers.
	Image::release(convertedPixels);

	// glBindTexture(GL_TEXTURE_2D, 0);
}

void Texture::readPixels(uchar* buffer, int bufferSize) const
{
	int requiredBufferSize = myWidth * myHeight * NumChannels[(int)myFormat];
	VortexAssertf(bufferSize == requiredBufferSize,
		"Buffer supplied to readPixels has incorrect size.");

	// glBindTexture(GL_TEXTURE_2D, myHandle);
	// glGetTexImage(GL_TEXTURE_2D, 0, FormatsGL[(int)myFormat], GL_UNSIGNED_BYTE, buffer);
	// glBindTexture(GL_TEXTURE_2D, 0);
}

void Texture::setWrapping(bool repeat)
{
	// glBindTexture(GL_TEXTURE_2D, myHandle);
	// glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat ? GL_REPEAT : GL_CLAMP);
	// glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat ? GL_REPEAT : GL_CLAMP);
	// glBindTexture(GL_TEXTURE_2D, 0);
}

void Texture::adjustHeight(int height)
{
	VortexAssert(height >= 1);

	int numChannels = NumChannels[(int)myFormat];

	uchar* pixels = nullptr;
	if (height > myHeight)
	{
		pixels = (uchar*)malloc(myWidth * height * numChannels);
		memset(pixels + myWidth * myHeight * numChannels, 0, myWidth * (myHeight - height) * numChannels);
	}
	else
	{
		pixels = (uchar*)malloc(myWidth * myHeight * numChannels);
	}

	// glBindTexture(GL_TEXTURE_2D, myHandle);
	// glGetTexImage(GL_TEXTURE_2D, 0, FormatsGL[(int)myFormat], GL_UNSIGNED_BYTE, pixels);
	// glTexImage2D(GL_TEXTURE_2D, 0, InternalFormatsGL[(int)myFormat], myWidth, height, 0,
	//	FormatsGL[(int)myFormat], GL_UNSIGNED_BYTE, pixels);
	// glBindTexture(GL_TEXTURE_2D, 0);

	myHeight = height;

	free(pixels);
}

} // namespace AV
